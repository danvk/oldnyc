General approach:
x Write a script to crop an image based on tesseract boxes
  -> Assess accuracy on 10 images
    710374b perfect
    715705b minor problem: missing first line ("(1)")
    718035b major problem: missing first line, last 4 and rightmost ~20 cols
            Box detection fails spectacularly on this one! Contrast is low.
            A better crop fixes this --> re-use my image cropper?
            Running unpaper with no arguments helps, too.
    721046b perfect (dark)
    722975b perfect
    726132b perfect
    726232b perfect
    726358b perfect (rotated)
    727425b perfect
    732437b perfect

  Running unpaper as a pre-processor (before makebox) fixes the major problem
  but not the minor problem --> probably a win?

  This sequence generates accurate crops:
    for x in $(ls *.reconstructed.jpg); do convert $x /tmp/blah.pgm; unpaper --overwrite /tmp/blah.pgm /tmp/unpaper.pgm; convert /tmp/unpaper.pgm ${x/reconstructed/unpapered}.png; done
    for x in $(ls *.unpapered.png); tesseract $x $(basename $x .png) batch.nochop makebox
    for x in $(ls *.unpapered.box); ~/github/oldnyc/ocr/tess/crop_to_box.py $x ${x/unpapered.box/reconstructed.jpg} ${x/unpapered.box/cropped.png}

x Write a script to generate histograms of box widths

    See https://docs.google.com/spreadsheets/d/1X7myP815ruxSD-UJ1CTp2BoP95svQJCvaEl-Wy2yO7Q/edit#gid=0

    Clear peaks @ 12, 24, 36
    Almost nothing @ w=16, 17, 18, 19

    16: (bad, handwritten) 727425b.cropped.box â€ 138 101 154 105 0
    16: (legit; oddly wide) 732437b.cropped.box m 292 26 308 38 0
    17: (bad, handwritten) 727425b.cropped.box * 257 169 274 180 0
    17: (bad, handwritten) 727425b.cropped.box 3 317 157 334 177 0
    17: (bad, handwritten) 727425b.cropped.box 5 335 156 352 177 0
    18: (bad, handwritten) 727425b.cropped.box Z 113 90 131 113 0
    19: (bad, handwritten) 718035b.cropped.box m 525 107 544 119 0
    19: (bad, handwritten) 721046b.cropped.box 7 225 21 244 52 0

    --> 20+, split it!

x Write a script to split boxes & add artificial white lines

- Compare accuracy of boxes on:
  - Cropped + binarized images (using Otsu or local adaptive)
  - Cropped + split images


-----

  The "unpaper" step helped with my initial sample of 10, but in a subsequent
pass on a sample of 25 there was another over-cropped image, even after
unpapering. I'm thinking that an image morphology approach (similar to what I
did for detecting photos on cards) might be better.

    brew install homebrew/python/scipy

Of my 25 sample images,

    _ have no border

    1 has a small border and brown paper
    6 have a small border and gray paper

    -> 7 have black border + text on gray paper
    -> 18 have black border, gray border, text on white paper

    1 has a watermark

    -> In all cases, cropping to the bbox of the largest black component will
       get rid of the first border.

    The text is typically centered. I could come up with some kind of score
    function for each row that gives greater weight to:
      1. white pixels near the center
      2. runs of white pixels

    Maybe each pixel is worth:
      e^-|distance from center| * (length of run)

    ... this doesn't distinguish short, off-center lines from the background.

Another approach is to:
1. Remove borders
2. Run canny edge detector
3. Select areas with lots of variance
  
  
Want to find the smallest rectangle that accounts for the most content.
-> f1 score!

My strategy was to start with the full image rectangle, then keep removing a
row or column from the left/right/top/bottom, whichever had the fewest white
pixels. This is greedy, which prevents it from working.
  -> maybe crop x & y independently?

Or do dilation to come up with larger components.

----

Sample of 50:
  - With four groups of text, missing the bottom-most (this is the worst issue)
  - Missing attribution block at the bottom (be more aggressive about recall?)
  - Missing "(1)", "(2)" on left side
  - Missing "(1)", "(2)" on left side
  - Missing "(1)", "(2)" on left side
  - Missing "(1)" on top, includes stamp outside border
  - Missing "(1)", "(2)" on left side
  - Includes "NYPL" stamp (solution: remove areas outside any borders)
  - Includes a smudge outside the border
  - Inluding a stamp outside the border
  - Inluding a stamp outside the border
  (other 39 were perfect)

Another sample of 25:
  - 724844b -- missing "(1)", "(2)" on left side
  - 721235b -- missing "(1)" on top
  - 722563b -- including a stamp on the bottom
  - 721028b -- missing a "(1)" on the top

(added a special condition for adding high-impact rectangles to get the last few bits)

Another sample of 25:
  + 713992b -- grab a wrinkle on the left side of the paper
  - 724294b -- entire sheet
  + 714291b -- includes stamp outside border
  - 724548b -- entire sheet
  - 710461b -- entire paper

My border detection technique is also affecting the text.
Maybe detecting & removing borders explicitly is a better idea.

Another sample of 25, it was basically perfect.
Another sample of 25,

  1 overcropped
  2 undercropped (708848b, 729772b)
